#!/bin/bash

# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# --------------------------------------------------------------------------------------------

#
# Watchdog for monitoring unmounts and stunnel processes
#

mtime_mountmap=0

#
# Kill stunnel process and clean up stunnel files generated by aznfs mount helper
#
cleanup_stunnel_files()
{
    local l_conf=$1
    local l_log=$2
    local l_pid=$3
    local accept_port

    # Kill stunnel process first.
    pid=$(cat $l_pid)
    accept_port=$(cat $l_conf | grep accept | cut -d ':' -f 2)
    pecho "killing stunnel process with pid: $pid on port: $accept_port"
    kill -9 $pid
    if [ $? -ne 0 ]; then
        eecho "Unable to kill stunnel process $pid!"
    fi

    # Cleanup stunnel files
    rm $l_log
    if [ $? -ne 0 ]; then
        eecho "[FATAL] Unable to delete stunnel log file $l_log!"
    fi

    rm $l_pid
    if [ $? -ne 0 ]; then
        eecho "[FATAL] Unable to delete stunnel pid file $l_pid!"
    fi

    chattr -if $l_conf
    rm $l_conf
    if [ $? -ne 0 ]; then
        eecho "[FATAL] Unable to delete stunnel conf file $l_conf!"
    fi
}

#
# Delete entry from MOUNTMAPv4.
#
ensure_mountmapv4_not_exist()
{
    #
    # If watchdog wants to delete the entry only if MOUNTMAPv4 has not changed since
    # watchdog looked up, honour that.
    #
    local mountmap_mtime="$2"
    if [ -n "$mountmap_mtime" ]; then
        local mtime=$(stat -c%Y $MOUNTMAPv4)
        if [ "$mtime" != "$mountmap_mtime" ]; then
            eecho "[$1] Refusing to remove from ${MOUNTMAPv4} as $mtime != $mountmap_mtime!"
            return 1
        fi
    fi

    chattr -f -i $MOUNTMAPv4
    #
    # We overwrite the file instead of inplace update by sed as that has a
    # very bad side-effect of creating a new MOUNTMAPv4 file. This breaks
    # any locking that we dependent on the old file.
    #
    out=$(sed "\%^${1}$%d" $MOUNTMAPv4)
    ret=$?
    if [ $ret -eq 0 ]; then
        #
        # If this echo fails then MOUNTMAPv4 could be truncated.
        #
        echo "$out" > $MOUNTMAPv4
        ret=$?
        out=
        if [ $ret -ne 0 ]; then
            eecho "*** [FATAL] MOUNTMAPv4 may be in inconsistent state, contact Microsoft support ***"
        fi
    fi

    chattr -f +i $MOUNTMAPv4

    if [ $ret -ne 0 ]; then
        eecho "[$1] failed to remove from ${MOUNTMAPv4}!"
        return 1
    fi

    pecho "[$1] removed from ${MOUNTMAPv4} successfully!"

    # Return the mtime after our mods.
    echo $(stat -c%Y $MOUNTMAPv4)
}

cleanup_mount()
{
    local l_conf=$1
    local l_log=$2
    local l_pid=$3
    local line=$4

    # Need to lock MOUNTMAPv4 since the mountscript could modify them as well.
    exec {fd2}<$MOUNTMAPv4
    flock -e $fd2

    # Delete IFF mountmap is not changed since we read it above.
    l_mtime=$(ensure_mountmapv4_not_exist "$line" "$mtime_mountmap")

    #
    # Update mountmap mtime in case of successful updation of MOUNTMAPv4,
    # so that we can distinguish between MOUNTMAPv4 mtime changing because
    # of our action or some mount helper changing it. In the former case
    # it's safe to update the MOUNTMAPv4, so update mtime_mountmap to the
    # mtime after this update.
    #
    if [ $? -eq 0 ]; then
        mtime_mountmap=$l_mtime
    else
        # If the mountmap file is changed since we read it, we need to read it again - don't modify anything.
        eecho "Failed to delete entry from ${MOUNTMAPv4}! Entry: [$line]"
        flock -u $fd2
        exec {fd2}<&-
        return 1
    fi

    cleanup_stunnel_files $l_conf $l_log $l_pid

    flock -u $fd2
    exec {fd2}<&-
    return 0
}

process_nfsv4_mounts()
{
    local l_conf
    local l_log
    local l_pid
    local l_checksumhash

    epoch_now=$(date +%s)

    #
    # Go over all lines in MOUNTMAPv4 and check them for two things:
    # 1. Is that entry still in use by at least one aznfs mount, if not remove the entry.
    # 2. Is stunnel process running?
    #
    # We store the mtime of MOUNTMAPv4 while inside the lock so that if any mount helper process
    # updates it after this we will skip modification for sake of safety. We will come to it
    # in the next iteration when it's safer.
    #
    exec {fd}<$MOUNTMAPv4
    flock -e $fd
    mtime_mountmap=$(stat -c%Y $MOUNTMAPv4)
    IFS=$'\n' lines=$(cat $MOUNTMAPv4)
    flock -u $fd
    exec {fd}<&-

    #
    # findmnt must be done after reading MOUNTMAPv4 so that if we come accross a
    # MOUNTMAPv4 entry whose all nfs file shares are unmounted, we know
    # for sure that it's not in use by any mount and can be removed.
    #
    findmnt=$(findmnt | grep 'nfs4\|$LOCALHOST' 2>&1)
    #findmnt=$(findmnt --raw --noheading -o MAJ:MIN,FSTYPE,SOURCE,TARGET,OPTIONS -t nfs 2>&1)
    #daniewo use this findmnt to check against the fslocation file for the IP

    #
    # For no matching mounts also, findmnt exits with a failure return, so check
    # for both exit status and non-empty error o/p.
    #
    if [ $? -ne 0 -a -n "$findmnt" ]; then
        eecho "${findmnt}."
        eecho "[FATAL] findmnt failed unexpectedly!"
        eecho "[FATAL] aznfswatchdogv4 service is exiting, will not monitor Azure NFS file shares."
        eecho "[FATAL] Please contact Microsoft support before using any NFS File shares."
        # This usually indicates some non-transient issue, bail out.
        exit 1
    fi

    if [ -z "$NETSTATCOMMAND" ]; then
        eecho "[FATAL] No socket statistics command (netstat or ss) found! Aznfswatchdogv4 service is exiting. Please contact Microsoft support"
        exit 1
    fi

    for line in $lines; do
        if [ -z "$line" ]; then
            continue
        fi

        #
        # MOUNTMAPv4 line is of the form:
        # <IP>;<stunnel_account.file.preprod.core.windows.net.conf path>;<stunnel_account.file.preprod.core.windows.net.log path>;<stunnel_account.file.preprod.core.windows.net.pid path>;<checksumHash>;<status>;<timeout>
        #
        #daniewo #stunnel_account here is the destination IP address for the account.
        #FSLOCATION will have FQDN IP1 IP2 or something like that. Look for IP1 and see if it's different than IP2

        IFS=";" read l_ip l_conf l_log l_pid l_checksumhash l_status l_timeout <<< "$line"  

        if [ -z "$l_ip" -o -z "$l_conf" -o -z "$l_pid" ]; then
            wecho "[FATAL] Deleting invalid line in $MOUNTMAPv4: [$line]!"
            exec {fd2}<$MOUNTMAPv4
            flock -e $fd2
            l_mtime=$(ensure_mountmapv4_not_exist "$line")
            [ $? -eq 0 ] && mtime_mountmap=$l_mtime
            flock -u $fd2
            exec {fd2}<&-
            continue
        fi

        # Skip if the status is waiting, which means the mountscript is still processing the mount.
        if [ "$l_status" == "waiting" ]; then
            # vecho "Skipping entry with status 'waiting': [$line]"
            if [[ $l_timeout -ge $(date +%s) ]]; then
                # Timeout is in future, skip this entry.
                # If a mount entry stays in the 'waiting' state for a long time (grater than the mount timeout), it's safe to clean it up.
                # vecho "Timeout is in future, skipping entry with status 'waiting': [$line]"
                continue
            fi
        fi

        accept_port=$(cat $l_conf | grep accept | cut -d ':' -f 2)
        vecho "accept_port: $accept_port"

        #
        # Delete entry from MOUNTMAPv4 if there are no mounted shares on that host.
        # As long as we have at least one mount using the MOUNTMAPv4 entry, we leave
        # it around.
        #
        if ! echo "$findmnt" | grep "$accept_port" >/dev/null; then
            pecho "No mounted shares for host $l_ip with accept port $accept_port, deleting from ${MOUNTMAPv4} [$line]."

            cleanup_mount $l_conf $l_log $l_pid $line
            continue
        else
        #daniewo section
            # vecho "Mounted shares found for host $l_ip with accept port $accept_port."
            #Daniewo updates for ip change detection
            #Do a check for cadence, don't do every iteration.
            #then, check here, we should check the FQDN -> IP from the above, l_host is the accountname, and then
            #grep against the l_conf for the IP
            #if IP is updated, then reconfigure stunnel and probably go to last step and skip this. or move this check
            # above

            # #daniewo get dest ip from mountmap file
            # ip_address=$(echo $l_conf | awk -F'.file' '{print $1}')
            # echo "The extracted IP address is: $ip_address"

            #get matching ip address with local ip. 
            #the format for FSLOCATION is FQDN old_ip new_ip l_prt
            #if no migration is happening, then old_ip and new_ip remains the same. 
            #when prt and/or migration has completed, new_ip will be updated. not sure about the lag.

            local fslocation_entry=$(grep $l_ip $VIRTUALFSLOCATION)
            #probably need to check if it returns empty as well.
            #we grab the entire lines, for each entry etc. 
            for entry in $fslocation_entry; do 
                eecho "daniewo fslocation_entry = $entry"

                #extract fslocation entry
                IFS=" " read l_fqdn old_ip new_ip l_prt <<< $fslocation_entry
                eecho "daniewo $l_fqdn, $old_ip, $new_ip, $l_prt"
                #if old ip != new ip, then reconfigure files
                if [ "$l_ip" != "$new_ip" ]; then
                    eecho "daniewo -------------- IP CHANGED -----------"
                    #daniewo do we need lock?
                    # use mv to edit file name

                    #sed command old ip with new ip in l_conf file. then mv after.
                    out=$(sed "s/${l_ip}/${new_ip}/g" $l_conf)

                    ret=$?
                    if [ $ret -eq 0 ]; then
                        chattr -f -i $l_conf
                        #
                        # If this echo fails then MOUNTMAPv4 could be truncated.
                        #
                        echo "$out" > $l_conf
                        ret=$?
                        out=
                        if [ $ret -ne 0 ]; then
                            eecho "*** [FATAL] MOUNTMAPv4 may be in inconsistent state, contact Microsoft support ***"
                        fi
                        chattr -f +i $l_conf
                    fi

                    #SED to change IP as well in FSLOCATION
                    outfslocation=$(sed "s/${l_ip}/${new_ip}/g" $VIRTUALFSLOCATION)
                    #echo into virtualfslocation

                    echo "$outfslocation" > $VIRTUALFSLOCATION
                    #calculate new PID for file once lines are updated.

                    #daniewo then mv the file? or create new one at this point? 
                    #daniewo use the paths above for l_conf, l_pid, l_logs and mv.
                    #$l_conf $l_log $l_pid $line

                    #update filepath for config file
                    new_file_path=$(echo "$l_conf" | sed "s/${l_ip}/${new_ip}/g")
                    chattr -f -i $l_conf
                    mv -vf $l_conf $new_file_path
                    chattr -f +i $new_file_path

                    eecho "daneiwo new conf path = $new_file_path"

                        
                    if [ $? -ne 0 ]; then
                        eecho "Failed to get the checksum hash of file: '${stunnel_conf_file}'!"
                        chattr -i -f $stunnel_conf_file
                        rm $stunnel_conf_file
                        exit 1
                    fi #maybe calculate before moving?

                    #checksumhash is only kept in mountmap, update with SED
                    chattr -f -i $MOUNTMAPv4

                    #calculate the new checksumhash fom new config file.

                    #update mountmapentry to update checksumhash and ip files
                    new_checksumHash=`cksum $new_file_path | awk '{print $1}'`
                    outmountmap=$(sed "s/$l_checksumhash/$new_checksumHash/g" -e "s/$l_ip/$new_ip/g" $MOUNTMAPv4)
                    eecho "daniewo ------ output for outmountmap $outmountmap"
                    
                    ret=$?
                    if [ $ret -eq 0 ]; then
                        #
                        # If this echo fails then MOUNTMAPv4 could be truncated.
                        #
                        eecho "daniewo content of $outmountmap"
                        echo "$outmountmap" > $MOUNTMAPv4
                        ret=$?
                        out=
                        if [ $ret -ne 0 ]; then
                            eecho "*** [FATAL] MOUNTMAPv4 may be in inconsistent state, contact Microsoft support ***"
                        fi
                    fi

                    chattr -f +i $MOUNTMAPv4

                    #update filepath for logs
                    new_file_path3=$(echo "$l_log" | sed "s/${l_ip}/${new_ip}/g")
                    eecho "daneiwo new log path = $new_file_path3"
                    chattr -f -i $l_log
                    mv -vf $l_log $new_file_path3
                    chattr -f +i $new_file_path3

                    #then move and restart stunnel, also calculate new pid, that should probably happen after
                    new_file_path2=$(echo "$l_pid" | sed "s/${l_ip}/${new_ip}/g")
                    eecho "daniewo new pid path = $new_file_path2"
                    chattr -f -i $l_pid
                    mv -vf $l_pid $new_file_path2
                    chattr -f +i $new_file_path2

                    # do the work here daniewo

                    #pid doesn't need to be updated as it should keep the same pid? Ask sepideh.

                    #update checksumhash in mountmapv4 file
                fi
            done

            eecho "daniewo fslocation_entry = $fslocation_entry"

            #extract fslocation entry
            IFS=" " read l_fqdn new_ip l_prt <<< $fslocation_entry
            eecho "daniewo $l_fqdn, $new_ip, $l_prt"

            # check fslocation ip against the old ip that was in mountmap file
            if [ "$ip_address" != "$new_ip" ]; then
            eecho "daniewwo IP for $l_host changed [$l_nfsip -> $new_ip]."
            fi

            # start the stunnel process
            stunnel_status_new=$(stunnel $new_file_path2)

            eecho "Daniewo stunnelstatus = $stunnel_status_new"

            # update_mountmapv3_entry version of TLS which will update the mountmapv4 entry and update stunnel

        #end daniewo section 

            # Check if checksumHash for stunnel.conf file has changed.
            # Customers should not modify stunnel.conf files created by aznfs mount helper.
            checksumHash=`cksum $l_conf | awk '{print $1}'`
            if [ $? -ne 0 ]; then
                eecho "Failed to get the checksum hash of file: '${l_conf}'!"
            fi

            if [ $checksumHash != $l_checksumhash && $old_ip == $new_ip]; then #daniewo skip if migrated
                eecho "'${l_conf}' file has modified!"
                eecho "It's not recommended to modify '${l_conf}' file created by aznfs mount helper!"
                eecho "watchdog service will do cleanup, kill stunnel process with pid:$(cat $l_pid) and remove '${l_conf}'; '${l_log}'; '${l_pid}'!"
                eecho "Please remount the shares from ${l_ip} using aznfs mount helper."

                cleanup_mount $l_conf $l_log $l_pid $line
                continue
            fi

            is_stunnel_running=$($NETSTATCOMMAND -anp | grep stunnel | grep `cat $l_pid`)
            if [ -z "$is_stunnel_running" ]; then
                vecho "Watchdog: stunnel is not running! Restarting the stunnel"

                stunnel_status=$(stunnel $l_conf 2>&1)
                if [ -n "$stunnel_status" ]; then
                    used_port=$(cat $l_conf | grep accept | cut -d: -f2)
                    is_binding_error=$(echo $stunnel_status | grep "$LOCALHOST:$used_port: Address already in use")
                    is_caroot_cert_failure=$(echo $stunnel_status | grep "certificate verify failed")
                    if [ -n "$is_binding_error" ]; then
                        eecho "[FATAL] Restarting stunnel failed.$used_port port is already being used by other process.!"
                        eecho "It's recommended to unmount all shares from $l_ip and then remount shares using aznfs mount helper!"
                    elif [ -n "$is_caroot_cert_failure" ]; then
                        eecho "[FATAL] Restarting stunnel failed. CA root certificate is either missing or is unable to authenticate TLS server certificate."
                        eecho "Please download the CA root certificate from https://learn.microsoft.com/en-us/azure/security/fundamentals/azure-ca-details"
                        eecho "It's recommended to unmount all shares from $l_ip and then remount shares using aznfs mount helper!"
                    else
                        eecho "[FATAL] watchdog service is unable to start stunnel process for '${l_conf}'!"
                        eecho "Please check the stunnel logs in $l_log for more details."
                        eecho "It's recommended to unmount all shares from $l_ip and then remount shares using aznfs mount helper!"
                    fi
                fi
            fi
        fi
    done
}

process_nfsv4_nontlsmounts()
{
    epoch_now=$(date +%s)
    vecho "Process nfsv4 non tls mounts"
    #
    # Go over all lines in MOUNTMAPv4NONTLS and check them for two things:
    # 1. Is that entry still in use by at least one aznfs mount, if not remove the entry.
    # 2. Has the Blob endpoint address changed from what is stored?
    #    If yes, update DNAT rule to point to the new address and update entry accordingly.
    #
    # Sample line in MOUNTMAPv4NONTLS.
    # account.blob.preprod.core.windows.net 10.100.100.100 52.230.170.200
    #
    # where the format is
    # blobendpoint_fqdn proxy_ip blobendpoint_ip
    #
    # We store the mtime of MOUNTMAPv4NONTLS while inside the lock so that if any mount helper process
    # updates it after this we will skip modification for sake of safety. We will come to it
    # in the next iteration when it's safer.
    #
    exec {fd}<$MOUNTMAPv4NONTLS
    #lock? 
    flock -e $fd
    mtime_mountmap=$(stat -c%Y $MOUNTMAPv4NONTLS)
    IFS=$'\n' lines=$(cat $MOUNTMAPv4NONTLS)
    flock -u $fd
    exec {fd}<&-

    #can tune this, but hardcode to true for now. 
    # vecho "now: $epoch_now"
    # vecho "next: $next_ip_change_detection_epoch"
    do_ip_change_detection=true
    # if [ $epoch_now -ge $next_ip_change_detection_epoch ]; then
    #     do_ip_change_detection=true
    #         next_ip_change_detection_epoch=$(expr $(date +%s) + $IP_CHANGE_DETECTION_FREQUENCY)
    # fi

    #do we need to findmnt? copy from nfsv4 or nfsv3 watchdog.
    findmnt=$(findmnt | grep 'nfs4' | grep -v "$LOCALHOST")

    #the bulk of this logic could be shared between v3 and v4 but would need to parameterize the file names

    for line in $lines; do
        if [ -z "$line" ]; then
            continue
        fi
        #
        # MOUNTMAPv4nontls line is of the form:
        # account.blob.preprod.core.windows.net <local ip> <public ip> [<PID>]
        #
        IFS=" " read l_host l_ip l_nfsip <<< "$line"

        eecho "l_host: $l_host"

        if [ -z "$l_host" -o -z "$l_ip" -o -z "$l_nfsip" ]; then
            wecho "[FATAL] Deleting invalid line in $MOUNTMAPv4NONTLS: [$line]!"
            l_mtime=$(ensure_mountmapv3_not_exist "$line")
            [ $? -eq 0 ] && mtime_mountmap=$l_mtime
            continue
        fi

        # Since we added it to the MOUNTMAPv4 file, it cannot be invalid.
        if ! is_private_ip "$l_ip"; then
            wecho "[FATAL] local ip ($l_ip) is invalid!"
            l_mtime=$(ensure_mountmapv3_not_exist "$line")
            [ $? -eq 0 ] && mtime_mountmap=$l_mtime
            continue
        fi

        # Since we added it to the MOUNTMAPv3 file, it cannot be invalid.
        if ! is_valid_ipv4_address "$l_nfsip"; then
            wecho "[FATAL] Blob endpoint ip ($l_nfsip) is invalid!"
            l_mtime=$(ensure_mountmapv3_not_exist "$line")
            [ $? -eq 0 ] && mtime_mountmap=$l_mtime
            continue
        fi

        #
        # Delete entry from MOUNTMAPv3 if there are no mounted shares on that host.
        # As long as we have at least one mount using the MOUNTMAPv3 entry, we leave
        # it around.
        #
        if ! echo "$findmnt" | grep "${l_ip}:" >/dev/null; then
            if $do_unmount_gc; then
                pecho "No mounted shares for host $l_host, deleting from ${MOUNTMAPv3} [$line]."

                # Delete IFF mountmap is not changed since we read it above.
                l_mtime=$(ensure_mountmapv3_not_exist "$line" "$mtime_mountmap")

                #
                # Update ifmatch time in case of successful updation of MOUNTMAPv3,
                # so that we can distinguish between MOUNTMAPv3 mtime changing because
                # of our action or some mount helper changing it. In the former case
                # it's safe to update the MOUNTMAPv3, so update mtime_mountmap to the
                # mtime after this update.
                #
                [ $? -eq 0 ] && mtime_mountmap=$l_mtime
                continue
            fi
        else
            #
            # Verify that iptable entry should be present for corresponding
            # MOUNTMAPv3 entry if the share is not unmounted.
            #
            # Note: This is extra protection in case user flushes the iptable
            #       entries or removes it by mistake. This should not be
            #       required normally.
            #
            # We also reconcile conntrack entries stuck in some bad states which
            # may hamper communication, f.e., in older kernels there's a bug due to
            # which conntrack entry may get stuck in SYN_SENT state if client
            # reuse the source port and keep retransmitting SYNs before the entry
            # can timeout.
            #
            reconcile_conntrack "$l_ip" "$l_nfsip"
            verify_iptable_entry "$l_ip" "$l_nfsip"
            eecho "Daniewo, we are at reconcile and verify IP table, sunny path"

        fi

        #
        # We do IP change detection less frequently than unmount detection
        # since it will cause DNS calls on network.
        # this will eventually call a read on our virtual file which will tell us the migration stage and IP
        #
        if ! $do_ip_change_detection; then
            continue
        fi

        eecho "Daniewo, now to ip change detection"

        #
        # See if the account is regional account and we need to skip IP change detection for that.
        #
        # if should_skip_regional_account "$l_host"; then
        #     continue
        # fi

        #
        # Check if blob endpoint IP address changed.
        # This is the migration check.
        # Daniewo (within this migration check here, we can force an update to the previous IP in the file so that it shows as a different IP now
        # and forces the IP to be different. )
        #
        #new_ip=$(resolve_ipv4 "$l_host" "false")
        # this new_ip will be read from fslocation
        #use a grep for the line. the format right now will be fqdn nfs_ip

        eecho "daniewo local_host is $l_host"

        fqdn_to_find=$l_host
        # local fslocation_entry=$grep -m1 "^${fqdn} " $MOUNTMAPv3
        
        local fslocation_entry=$(grep -m1 $fqdn_to_find $VIRTUALFSLOCATION)

        eecho "daniewo fslocation_entry = $fslocation_entry"
        # FSLOCATION file will have format 
        #lock FSLOCATION and find the line that has the matching FQDN == L_HOST
        # FQDN DestinationIP PRT
        # fqdn_to_find=$l_host
        # nfs_ip=$(grep -m 1 "^$fqdn_to_find " $VIRTUALFSLOCATION | awk '{print $2}')

        IFS=" " read l_fqdn new_ip l_prt <<< $fslocation_entry
        eecho "daniewo $l_fqdn, $new_ip, $l_prt"

        #daniewo check why this error code is not working

        # # If we fail to resolve the host name, try next time.
        # if [ $? -ne 0 ]; then
        #     #
        #     # If account is deleted then we need to delete the MOUNTMAPv3 entry along
        #     # with the proxy iptable entry created for that account.
        #     # Note that we don't delete if the MOUNTMAPv3 was changed recently since
        #     # the account may have been re-created after the dns lookup failure.
        #     #
        #     if [ "$new_ip" == "NXDOMAIN" ]; then
        #         pecho "Account corresponding to $l_host seems to have been deleted, deleting from ${MOUNTMAPv3} [$line]!"

        #         l_mtime=$(ensure_mountmapv3_not_exist "$line" "$mtime_mountmap")
        #         [ $? -eq 0 ] && mtime_mountmap=$l_mtime
        #     else
        #         eecho "resolve_ipv4($l_host) failed: $new_ip"
        #     fi
        #     continue
        # fi

        #then check IP detection change to see if it updates DNAT rules etc.

        #
        # If the IP changed for the Blob endpoint, we need to update the DNAT rule.
        # This will take care of migration/failover causing the Blob endpoint IP to change.
        #
        if [ "$new_ip" != "$l_nfsip" ]; then
            eecho "daniewwo IP for $l_host changed [$l_nfsip -> $new_ip]."

            #if IP changed, still update the DNAT Rule but also see if this ends up being a ZRS tenant.
            #Not sure what we will do for ZRS though, as we probably should not mount and only detect IP changes from fslocation
            #but maybe FS location can return some sort of flag that says "hey we are ZRS FYI"
            check_for_regional_account "$l_host"

            #danniewo, watch out for this as if we are mounting a ZRS account,
            # this can potentially be noisy.

            # This will update DNAT rule as well.
            if ! update_mountmapv3_entry "$line" "$l_host $l_ip $new_ip"; then
                eecho "Will reattempt the operation in next iteration."
            else
                eecho "daniewo empty"
                # mountpoint2048=$(echo "$findmnt" 2>/dev/null | egrep -m1 " nfs ${l_ip}:.*\<port=2048\>" | awk '{print $4}')
                # mountpoint2048=$(echo -e "$mountpoint2048")
                # if [ -n "$mountpoint2048" ]; then
                #     ping_new_endpoint "$mountpoint2048" &
                # fi
            fi
        fi
    done

}

# Load common aznfs helpers.
AZNFS_VERSION=4
. /opt/microsoft/aznfs/common.sh

vecho "Starting aznfswatchdog for NFSv4..."

# Detect and log distro, bash and AZNFS-mount version
log_version_info

if ! chattr -f +i $MOUNTMAPv4; then
    wecho "chattr does not work for ${MOUNTMAPv4}!"
fi

while :; do
    sleep $MONITOR_INTERVAL_SECS
    process_nfsv4_mounts
    #process_nfsv4_nontlsmounts
    #daniewo process nontlsmounts and track for migration

done
#!/bin/bash 

# 
# This stores the map of local IP and share name and external blob endpoint IP. 
# 

IPMAP="/tmp/azfs-ipmap.txt" 

#  
# How often does the watchdog look for unmounts and/or IP address changes for 
# Blob endpoints. 
# 

MONITOR_INTERVAL_SECS=5 

# 
# Default order in which we try the network prefixes for a free local IP to use. 
# This can be overriden using AZFS_IP_PREFIXES environment variable. 
# 

DEFAULT_AZFS_IP_PREFIXES="10.100 192.168 172.16" 

IP_PREFIXES="${AZFS_IP_PREFIXES:-${DEFAULT_AZFS_IP_PREFIXES}}" 

# 
# Check if the given string is a correctly formatted IPv6 address. 
# 

is_valid_ipv6_address() 
{
    # First line does basic sanity check, needed to weed out CIDR format addresses. 
    [[ $1 =~ ^[a-fA-F0-9:]+$ ]] && 
    ip -6 route save match "$1" > /dev/null 2>&1 
} 

# 
# Check if the given string is a valid IPv4 address. 
# 

is_valid_ipv4_address() 
{ 
    # ip route allows 10.10 as a valid address and treats it as 10.10.0.0, so we need the first coarse filter too. 
    [[ $1 =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] && 
    ip -4 route save match $1 > /dev/null 2>&1 
} 

# 
# Check if the given string is probably a hostname (as opposed to an IP address). 
# 

is_probably_hostname() 
{ 
    ! ip route save match $1 > /dev/null 2>&1
} 

is_valid_blob_fqdn() 

{ 
    # XXX Are there other valid blob endpoint fqdns? 
    [[ $1 =~ ^([a-z0-9]{3,24}).blob(.preprod)?.core.windows.net$ ]] 
} 

# 
# Blob fqdn to IPv4 adddress. 
# 

resolve_ipv4() 
{ 
    local hname="$1" 

    # 
    # If already IPv4 address, return it. 
    # 

    if ! is_probably_hostname "$hname"; then 
        echo "$hname" 
        return 0 
    fi 

    # 
    # else, resolve hostname to IPv4 address. 
    # 

    host_op=$(host -4 -t A "$hname") 
    if [ $? -ne 0 ]; then 
        echo "Bad server: $hname" 
        return 1 
    fi 

    # 
    # TODO: We should disallow ZRS endpoints which resolve to multiple addresses. 
    #       Though we should handle public ZRS endpoints for handling cases where 
    #       the currently connected cluster goes down. 
    # 

    local cnt_ip=$(echo "$host_op" | grep " has address " | awk '{print $4}' | wc -l) 

    if [ $cnt_ip -ne 1 ]; then 
        echo "host returned $cnt_ip address(es) for $hname, expected 1" 
        return 1 
    fi 

    local ipv4_addr=$(echo "$host_op" | grep " has address " | head -n1 | awk '{print $4}') 
    if ! is_valid_ipv4_address "$ipv4_addr"; then 
        echo "host returned bad IPv4 address $ipv4_addr for hostname $hname!!" 
        return 1 
    fi 

    echo $ipv4_addr 
    return 0 
}

# 
# Get host from host:/dir 
# 

get_host_from_share() 
{ 
    local share="$1" 
    echo $share | cut -d: -f1 
} 

# 
# Get dir from host:/dir 
# 

get_dir_from_share() 
{ 
    local share="$1" 
    echo $share | cut -d: -f2 
} 

#
# Is the given address one of the host addresses? 
# 

is_host_ip() 
{ 
    # XXX Don't make this local as status gathering doesn't work well when collecting command o/p to local variables. 
    route=$(ip -4 route get fibmatch $1 2>/dev/null) 
    if [ $? -ne 0 ]; then 
        return 1 
    fi 

    if ! echo "$route" | grep -q "scope host"; then 
        return 1 
    fi 

    return 0 
} 

 
# 
# Is the given address one of the addresses directly reachable from the host? 
# 

is_link_ip() 
{ 
    # XXX Don't make this local as status gathering doesn't work well when collecting command o/p to local variables. 
    route=$(ip -4 route get fibmatch $1 2>/dev/null) 
    if [ $? -ne 0 ]; then 
        return 1 
    fi 

    if ! echo "$route" | grep -q "scope link"; then 
        return 1 
    fi 

    return 0 
} 

# 
# Check if a given IPv4 address is responding to ICMP pings. 
# Uses a 3 secs timeout to bail out in time if address is not responding. 
# 

is_pinging() 
{ 
    local ip=$1; 

    # 3 secs timeout should be good. 

    ping -4 -W3 -c1 $ip > /dev/null 
} 


# 
# Get a local IP that's free to use. 
# 

get_free_local_ip() 
{ 
    for ip_prefix in $IP_PREFIXES; do 

        local local_ip="" 

        # Start from 100 onwards to make azfs local addresses more identifiable. 

        for ((_3rdoctet=100; _3rdoctet<255; _3rdoctet++)) { 
            ip_prefix="${ip_prefix}.$_3rdoctet" 

            if is_host_ip $ip_prefix; then 
                echo "$ip_prefix is host network!" 1>&2 
                continue 
            fi 

            if is_link_ip $ip_prefix; then 
                echo "$ip_prefix is link network!" 1>&2 
                continue 
            fi 

            break 
        } 

        if [ $_3rdoctet -eq 255 ]; then 
            continue 
        fi 

        if [ -z "$ip_prefix" ]; then 
            echo "ip_prefix is nil!" 
            return 1 
        fi 

        for ((_4thoctet=100; _4thoctet<255; _4thoctet++)) { 
            local_ip="${ip_prefix}.$_4thoctet" 

            if egrep "\<$local_ip\>" $IPMAP >/dev/null; then 
                echo "$local_ip is in use by azfs!" 1>&2 
                continue; 
            fi 

            # 
            # TODO: Do ping check to be sure the address is not in use in 
            #       the client's network. 
            # 

            echo "Using local IP $local_ip for azfs" 1>&2 
            break 
        } 

        if [ $_4thoctet -eq 255 ]; then 
            continue 
        fi 

        if [ -z "$local_ip" ]; then 
            echo "local_ip is nil!" 
            return 1 
        fi 

        # Happy path! 
        echo "$local_ip" 
        return 0 
    done 

    # 
    # If we come here we didn't get a free address to use. 
    # 

    echo "Couldn't find a free local IP to use for azfs using DEFAULT_AZFS_IP_PREFIXES=$DEFAULT_AZFS_IP_PREFIXES!" 
    echo "Set AZFS_IP_PREFIXES env variable correctly to provide free addresses for use by azfs!" 

    return 1 
} 

update_ipmap() 

{ 
    echo "" 
} 


# 
# Watchdog for monitoring unmounts and more importantly change in blob endpoint 
# addresses possibly as a result of migration. 
# 
# TODO: This must be a separate process started by init/systemd. 
# 

azfs_watchdog() 
{ 
    # Disable signal to make this slightly more resilient. 
    trap "" INT QUIT TSTP 

    while :; do 
        sleep $MONITOR_INTERVAL_SECS 

        findmnt=$(findmnt --raw --noheading -o MAJ:MIN,FSTYPE,SOURCE,TARGET,OPTIONS -t nfs) 

        if [ $? -ne 0 ]; then 
            echo "findmnt failed!" 
            # Hope things improve next time around! 
            continue 
        fi 

        # Nothing mounted, so nothing to check. 
        if [ -z "$findmnt" ]; then 
            continue 
        fi 

        # 
        # Go over all lines in $IPMAP and check them for two things: 
        # 1. Is that entry still mounted, if not remove the entry. 
        # 2. Has the Blob endpoint address changed from what is stored? 
        #    If yes, update DNAT rule to point to the new address. 
        # 
        # Sample line in $IPMAP. 
        # nfsv3stdaccount20.blob.preprod.core.windows.net:/nfsv3stdaccount20/fstestbase3 10.100.100.100 52.239.178.215 
        #  
        # where the format is 
        # <blobendpoint:/account/container local_ip blobendpoint_ip 
        # 

        IFS=$'\n' lines=$(cat $IPMAP) 

        for line in $lines; do 
            if [ -z "$line" ]; then 
                continue 
            fi 

            l_share=$(echo "$line" | awk '{print $1}') 
            l_host=$(echo "$l_share" | cut -d: -f1) 
            l_dir=$(echo "$l_share" | cut -d: -f2) 
            l_ip=$(echo "$line" | awk '{print $2}') 
            l_nfsip=$(echo "$line" | awk '{print $3}') 
 
            if [ -z "$l_host" -o -z "$l_dir" -o -z "$l_ip" -o -z "$l_nfsip" ]; then 
                echo "Skipping invalid line in $IPMAP: [$line]" 
                continue 
            fi 


            # Since we added it to the IPMAP file, it cannot be invalid. 

            if ! is_valid_ipv4_address "$l_ip"; then 
                echo "[BUG] local ip ($l_ip) is invalid!" 
                continue 
            fi 

 
            # Since we added it to the IPMAP file, it cannot be invalid. 
			
            if ! is_valid_ipv4_address "$l_nfsip"; then 
                echo "[BUG] Blob endpoint ip ($l_nfsip) is invalid!" 
                continue 
            fi 

 
            # 
            # Local share name. Note that we mount the local IP and not the actual Blob endpoint IP and 
            # map local IP to actual Blob endpoint IP using DNAT rule. 
            # 

            m_share="$l_ip:$l_dir" 
          
            # 
            # Delete entry from IPMAP if share is unmounted. 
            # TODO: What if user unmounts and mounts before MONITOR_INTERVAL_SECS secs? 
            # 

            if ! echo "$findmnt" | grep " nfs $m_share " > /dev/null; then 
                # delete the line from IPMAP file. 
                echo "[$date] Deleting unmounted share $m_share" 
                chattr -i $IPMAP 
                sed -i "/ $l_ip $l_nfsip/d" $IPMAP 
                chattr +i $IPMAP 
                iptables -t nat -D OUTPUT -p tcp -d "$l_ip" -j DNAT --to-destination "$l_nfsip" 
            fi 
 
            # 
            # Check if blob endpoint IP address changed. 
            # This is the migration check. 
            # 

            new_ip=$(resolve_ipv4 "$l_host") 
 
            # If we fail to resolve the host name, try next time. 

            if [ $? -ne 0 ]; then 
                echo "resolve_ipv4($l_host) failed!" 
                continue 
            fi 
 
            if ! is_valid_ipv4_address "$new_ip"; then 
                echo "resolve_ipv4($l_host) returned invalid IPv4 address ($new_ip)!" 
                continue 
            fi 
 
            # 
            # If the IP changed for the Blob endpoint, we need to update the DNAT rule. 
            # This will take care of migration/failover causing the Blob endpoint IP to change. 
            # 
            # TODO: Make this less frequent than the unmount check. 
            # 
            #echo "$l_host: new_ip=$new_ip, l_nfsip=$l_nfsip" 

            if [ "$new_ip" != "$l_nfsip" ]; then 
                echo "IP for $l_host changed [$l_nfsip -> $new_ip]" 
                chattr -i $IPMAP 
                sed -i "/ $l_ip $l_nfsip/d" $IPMAP 
                chattr +i $IPMAP 
 
                # Delete old DNAT rule and the conntrack entry to stop current active connections too. 
                iptables -t nat -D OUTPUT -p tcp -d "$l_ip" -j DNAT --to-destination "$l_nfsip" 
                conntrack -D conntrack -p tcp -d "$l_ip" -r "$l_nfsip" 
 
                # Add new DNAT rule. 

                iptables -t nat -A OUTPUT -p tcp -d "$l_ip" -j DNAT --to-destination "$new_ip" 
                chattr -i $IPMAP 
                echo "$l_host:$l_dir $l_ip $new_ip" >> $IPMAP 
                chattr +i $IPMAP 
            fi 
        done 
    done 
} 

 

##### Action starts here ##### 
 
# [52.239.178.215:/nfsv3stdaccount20/fstestbase3 /mnt/azfs -o rw,tcp,nolock,nconnect=16] 
echo "Got arguments: [$*]" 
 
# 
# Truncate IPMAP if it exists. 
# Keep it protected from undesired mods using the immutable attribute. 
# 

> $IPMAP 
chattr +i $IPMAP 
 
# 
# If old watchdog running, kill it. 
# 

pids=$(pidof -x /sbin/mount.azfs) 

for pid in $pids; do 
    # Avoid killing ourselves! 
    if [ $pid -ne $$ ]; then 
        echo "Killing old watchdog with pid $pid" 
        kill -9 $pid 
    fi 
done 

 
nfs_host=$(get_host_from_share "$1") 

 
if ! is_valid_blob_fqdn $nfs_host; then 
    echo "Not a valid Azure Blob NFS endpoint: $nfs_host" 
    exit 1 
fi 

 
nfs_ip=$(resolve_ipv4 $nfs_host) 
if [ -z "$nfs_ip" ]; then 
    echo "Cannot resolve IP address for $nfs_host!" 
    exit 1 
fi 
 

nfs_dir=$(get_dir_from_share "$1") 
if [ -z "$nfs_dir" ]; then 
    # TODO: Check for /account/container format. 
    echo "Improper share name: $1" 
    exit 1 
fi 

 
mount_point="$2" 
mount_options="$4" 

 
local_ip=$(get_free_local_ip) 
 

echo "nfs_host=[$nfs_host]" 
echo "nfs_ip=[$nfs_ip]" 
echo "nfs_dir=[$nfs_dir]" 
echo "mount_point=[$mount_point]" 
echo "mount_options=[$mount_options]" 
echo "local_ip=$local_ip" 
 

# 
# Set DNAT rule for forwarding local_ip traffic to the actual blob endpoint IP. 

iptables -t nat -A OUTPUT -p tcp -d "$local_ip" -j DNAT --to-destination "$nfs_ip" 

if [ $? -ne 0 ]; then 
    echo "iptables failed to set DNAT rule [$local_ip -> $nfs_ip]" 
    exit 1 
fi 

 
mount -t nfs -o "$mount_options" "${local_ip}:${nfs_dir}" "$mount_point" 

if [ $? -ne 0 ]; then 
    echo "mount failed!" 
    # clear the DNAT rule. 
    iptables -t nat -D OUTPUT -p tcp -d "$local_ip" -j DNAT --to-destination "$nfs_ip" 
    exit 1 
fi 

 
# Update IPMAP. 
chattr -i $IPMAP 
echo "$nfs_host:$nfs_dir $local_ip $nfs_ip" >> $IPMAP 
chattr +i $IPMAP 
 

# Start the watchdog. 
azfs_watchdog & 

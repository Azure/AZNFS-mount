#!/bin/bash

# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# --------------------------------------------------------------------------------------------

# Are we running inside the AKS?
AKS_USER="false"

#
# How often does the watchdog look for unmounts and/or IP address changes for
# Blob and nfs file endpoints.
#
MONITOR_INTERVAL_SECS=5

# How often do we check for change in FQDN->IP?
IP_CHANGE_DETECTION_FREQUENCY=60

# How often do we check for updates of AZNFS?
UPDATE_DETECTION_FREQUENCY=86400

#
# Remove unmounted entries only if MOUNTMAP has not been changed till MONITOR_INTERVAL_SECS seconds.
# Don't set it below 3 minutes.
#
MOUNTMAP_INACTIVITY_SECS=300

#
# Don't perform mountmap and iptables rule cleanup for unmounted filesystems.
# This can be set if you want lazy umount to work.
#
AZNFS_SKIP_UNMOUNT_CLEANUP="${AZNFS_SKIP_UNMOUNT_CLEANUP:-0}"

# TIMEWAIT timeout to be used for conntrack entries.
AZNFS_TIMEWAIT_TIMEOUT="${AZNFS_TIMEWAIT_TIMEOUT:-65}"

next_ip_change_detection_epoch=0

# Defer update detection to 1 minute after start to avoid issues with auto-update.
next_update_detection_epoch=$(expr $(date +%s) + 60)

LOCALHOST="127.0.0.1"

# Load common aznfs helpers.
. /opt/microsoft/aznfs/common.sh


# Create /opt/microsoft/aznfs/data/randbytes if not already created.
if [ ! -s $RANDBYTES ]; then
        dd if=/dev/urandom of=$RANDBYTES bs=256 count=1
fi
if [ ! -s $RANDBYTES ]; then
        uuidgen > $RANDBYTES
fi
if [ ! -s $RANDBYTES ]; then
        date | md5sum | awk '{print $1}' > $RANDBYTES
fi
if [ ! -s $RANDBYTES ]; then
        date > $RANDBYTES
fi
chattr -f +i $RANDBYTES

#
# Hash for storing how many times we have seen a conntrack entry in SYN_SENT state.
# Used for finding if some entry is stuck in SYN_SENT state due to a bug in older
# kernels. If we find an entry stuck for more than a certain time in SYN_SENT state
# we delete the entry so that kernel looks up fresh NAT rules and creates a new entry.
#
declare -A cthash_synsent
declare -A cthash_synsent_now

reconcile_conntrack_one()
{
    local l_ip=$1
    local l_sport=$2
    local l_dport=$3
    local l_nfsip=$4

    key="${l_ip}:${l_sport}:${l_dport}:${l_nfsip}"
    let cthash_synsent[$key]++
    let cthash_synsent_now[$key]++

    #
    # We are called every 5 secs, so this deletes an entry stuck in
    # SYN_SENT for 25/30 secs.
    #
    if [ ${cthash_synsent[$key]} -ge 5 ]; then
        cmd="conntrack -D -p tcp -d $l_ip -r $l_nfsip --sport $l_sport --dport $l_dport"
        wecho "Deleting conntrack entry stuck in SYN_SENT state [$cmd]"

        eval $cmd
        if [ $? -ne 0 ]; then
            eecho "Failed to delete conntrack entry [$cmd]!"
        else
            unset cthash_synsent[$key]
        fi
    fi
}

reconcile_conntrack()
{
    local l_ip=$1
    local l_nfsip=$2

    # cthash_synsent_now holds only entries found in this call, so clear it before starting.
    unset cthash_synsent_now
    declare -A cthash_synsent_now

    #
    # For mounts with nconnect, there could be more than one conntrack entries to the same
    # proxy IP, but with different local ports. We must track them separately.
    #
    IFS=$'\n' output111=$(conntrack -L -p tcp -d $l_ip -r $l_nfsip --dport 111 --state SYN_SENT 2>/dev/null)
    IFS=$'\n' output2048=$(conntrack -L -p tcp -d $l_ip -r $l_nfsip --dport 2048 --state SYN_SENT 2>/dev/null)
    output="$output111"$'\n'"$output2048"

    if [ -n "$output" ]; then
        for line in $output; do
            # XXX Remove this log after running for few days.
            vecho "$line"

            matchstr=".* SYN_SENT src=.* dst=$l_ip sport=([0-9]+) dport=([0-9]+).*"
            if [[ "$line" =~ $matchstr ]]; then
                l_sport=${BASH_REMATCH[1]}
                l_dport=${BASH_REMATCH[2]}
                reconcile_conntrack_one $l_ip $l_sport $l_dport $l_nfsip
            fi
        done
    fi

    #
    # Any port that is not stuck now, means it's recovered since the last time and can be removed
    # from the global cthash_synsent map.
    #
    for key in "${!cthash_synsent[@]}"; do
        if [ ! -v cthash_synsent_now[$key] ]; then
            unset cthash_synsent[$key]
        fi
    done
}


#
# Delete entry from $AZ_FILES_MOUNTMAP.
#
ensure_az_files_mountmap_not_exist()
{
    (
        flock -e 999

        #
        # If watchdog wants to delete the entry only if AZ_FILES_MOUNTMAP has not changed since
        # watchdog looked up, honour that.
        #
        local ifmatch="$2"
        if [ -n "$ifmatch" ]; then
            local mtime=$(stat -c%Y $AZ_FILES_MOUNTMAP)
            if [ "$mtime" != "$ifmatch" ]; then
                eecho "[$1] Refusing to remove from ${AZ_FILES_MOUNTMAP} as $mtime != $ifmatch!"
                return 1
            fi
        fi

        chattr -f -i $AZ_FILES_MOUNTMAP
        #
        # We do this thing instead of inplace update by sed as that has a
        # very bad side-effect of creating a new AZ_FILES_MOUNTMAP file. This breaks
        # any locking that we dependent on the old file.
        #
        out=$(sed "\%^${1}$%d" $AZ_FILES_MOUNTMAP)
        ret=$?
        if [ $ret -eq 0 ]; then
            #
            # If this echo fails then AZ_FILES_MOUNTMAP could be truncated.
            #
            echo "$out" > $AZ_FILES_MOUNTMAP
            ret=$?
            out=
            if [ $ret -ne 0 ]; then
                eecho "*** [FATAL] AZ_FILES_MOUNTMAP may be in inconsistent state, contact Microsoft support ***"
            fi
        fi

        if [ $ret -ne 0 ]; then
            chattr -f +i $AZ_FILES_MOUNTMAP
            eecho "[$1] failed to remove from ${AZ_FILES_MOUNTMAP}!"
            return 1
        fi
        chattr -f +i $AZ_FILES_MOUNTMAP

        # Return the mtime after our mods.
        echo $(stat -c%Y $AZ_FILES_MOUNTMAP)
    ) 999<$AZ_FILES_MOUNTMAP
}

#
# Kill stunnel process and clean up stunnel files generated by aznfs mount helper
#
cleanupStunnelFiles()
{
    local l_conf=$1
    local l_log=$2
    local l_pid=$3

    # Kill stunnel process first.
    pid=$(cat $l_pid)
    kill -9 $pid
    if [ $? -ne 0 ]; then
        eecho "[FATAL] Unable to kill stunnel process $pid!"
    fi

    # Cleanup stunnel files
    rm $l_log
    if [ $? -ne 0 ]; then
        eecho "[FATAL] Unable to delete stunnel log file $l_log!"
    fi

    rm $l_pid
    if [ $? -ne 0 ]; then
        eecho "[FATAL] Unable to delete stunnel pid file $l_pid!"
    fi

    chattr -if $l_conf
    rm $l_conf
    if [ $? -ne 0 ]; then
        eecho "[FATAL] Unable to delete stunnel conf file $l_conf!"
    fi
}

#
# Watchdog for monitoring unmounts and more importantly change in blob endpoint
# addresses possibly as a result of migration.
#
processNFS3Mounts()
{
    #
    # TODO: Add a function reconcile_mountmap() and call it from here. This
    #       should reconstruct the MOUNTMAP file from findmnt and output of
    #       iptables. This will be added in subsequent revisions.
    #

    epoch_now=$(date +%s)

    # Check for AZNFS updates.
    check_for_latest_update=false
    if [ "$AKS_USER" != "true" ] && [ $epoch_now -ge $next_update_detection_epoch ]; then
        check_for_latest_update=true
        next_update_detection_epoch=$((epoch_now + UPDATE_DETECTION_FREQUENCY))
    fi

    if $check_for_latest_update; then
        if [ -e "$INSTALLSCRIPT" ]; then
            "$INSTALLSCRIPT" "auto-update"
        else
            wecho "[FATAL] $INSTALLSCRIPT not found. This is an unexpected error!"
            Wecho "[FATAL] Please contact Microsoft support."
        fi
    fi

    #
    # Go over all lines in $MOUNTMAP and check them for two things:
    # 1. Is that entry still in use by at least one aznfs mount, if not remove the entry.
    # 2. Has the Blob endpoint address changed from what is stored?
    #    If yes, update DNAT rule to point to the new address and update entry accordingly.
    #
    # Sample line in $MOUNTMAP.
    # account.blob.preprod.core.windows.net 10.100.100.100 52.230.170.200
    #
    # where the format is
    # blobendpoint_fqdn proxy_ip blobendpoint_ip
    #
    # We store the mtime of MOUNTMAP while inside the lock so that if any mount helper process
    # updates it after this we will skip modification for sake of safety. We will come to it
    # in the next iteration when it's safer.
    #
    exec {fd}<$MOUNTMAP
    flock -e $fd
    mtime_mountmap=$(stat -c%Y $MOUNTMAP)
    IFS=$'\n' lines=$(cat $MOUNTMAP)
    flock -u $fd
    exec {fd}<&-

    do_ip_change_detection=false
    if [ $epoch_now -ge $next_ip_change_detection_epoch ]; then
        do_ip_change_detection=true
        next_ip_change_detection_epoch=$(expr $(date +%s) + $IP_CHANGE_DETECTION_FREQUENCY)
    fi

    #
    # Do unmount GC only if MOUNTMAP file is not modified in the last
    # MOUNTMAP_INACTIVITY_SECS seconds. We don't want to incorrectly delete an
    # entry while some aznfs mount is ongoing.
    #
    do_unmount_gc=false
    if [ "$AZNFS_SKIP_UNMOUNT_CLEANUP" == "0" ]; then
        if [ $epoch_now -ge $(expr $mtime_mountmap + $MOUNTMAP_INACTIVITY_SECS) ]; then
            do_unmount_gc=true
        fi
    fi

    #
    # findmnt must be done after reading MOUNTMAP so that if we come accross a
    # MOUNTMAP entry whose proxy_ip is not used by any existing mount, we know
    # for sure that it's not in use by any mount and can be removed.
    #
    findmnt=$(findmnt --raw --noheading -o MAJ:MIN,FSTYPE,SOURCE,TARGET,OPTIONS -t nfs 2>&1)

    #
    # For no matching mounts also, findmnt exits with a failure return, so check
    # for both exit status and non-empty error o/p.
    #
    if [ $? -ne 0 -a -n "$findmnt" ]; then
        eecho "${findmnt}."
        eecho "[FATAL] findmnt failed unexpectedly!"
        eecho "[FATAL] Aznfswatchdog service is exiting, will not monitor Azure NFS shares."
        eecho "[FATAL] Please contact Microsoft support before using any Blob NFS shares."
        # This usually indicates some non-transient issue, bail out.
        exit 1
    fi

    for line in $lines; do
        if [ -z "$line" ]; then
            continue
        fi

        #
        # MOUNTMAP line is of the form:
        # account.blob.preprod.core.windows.net <local ip> <public ip> [<PID>]
        #
        IFS=" " read l_host l_ip l_nfsip <<< "$line"

        if [ -z "$l_host" -o -z "$l_ip" -o -z "$l_nfsip" ]; then
            wecho "[FATAL] Deleting invalid line in $MOUNTMAP: [$line]!"
            l_mtime=$(ensure_mountmap_not_exist "$line")
            [ $? -eq 0 ] && mtime_mountmap=$l_mtime
            continue
        fi

        # Since we added it to the MOUNTMAP file, it cannot be invalid.
        if ! is_private_ip "$l_ip"; then
            wecho "[FATAL] local ip ($l_ip) is invalid!"
            l_mtime=$(ensure_mountmap_not_exist "$line")
            [ $? -eq 0 ] && mtime_mountmap=$l_mtime
            continue
        fi

        # Since we added it to the MOUNTMAP file, it cannot be invalid.
        if ! is_valid_ipv4_address "$l_nfsip"; then
            wecho "[FATAL] Blob endpoint ip ($l_nfsip) is invalid!"
            l_mtime=$(ensure_mountmap_not_exist "$line")
            [ $? -eq 0 ] && mtime_mountmap=$l_mtime
            continue
        fi

        #
        # Delete entry from MOUNTMAP if there are no mounted shares on that host.
        # As long as we have at least one mount using the MOUNTMAP entry, we leave
        # it around.
        #
        if ! echo "$findmnt" | grep " nfs ${l_ip}:" >/dev/null; then
            if $do_unmount_gc; then
                pecho "No mounted shares for host $l_host, deleting from ${MOUNTMAP} [$line]."

                # Delete IFF mountmap is not changed since we read it above.
                l_mtime=$(ensure_mountmap_not_exist "$line" "$mtime_mountmap")

                #
                # Update ifmatch time in case of successful updation of MOUNTMAP,
                # so that we can distinguish between MOUNTMAP mtime changing because
                # of our action or some mount helper changing it. In the former case
                # it's safe to update the MOUNTMAP, so update mtime_mountmap to the
                # mtime after this update.
                #
                [ $? -eq 0 ] && mtime_mountmap=$l_mtime
                continue
            fi
        else
            #
            # Verify that iptable entry should be present for corresponding
            # MOUNTMAP entry if the share is not unmounted.
            #
            # Note: This is extra protection in case user flushes the iptable
            #       entries or removes it by mistake. This should not be
            #       required normally.
            #
            # We also reconcile conntrack entries stuck in some bad states which
            # may hamper communication, f.e., in older kernels there's a bug due to
            # which conntrack entry may get stuck in SYN_SENT state if client
            # reuse the source port and keep retransmitting SYNs before the entry
            # can timeout.
            #
            reconcile_conntrack "$l_ip" "$l_nfsip"
            verify_iptable_entry "$l_ip" "$l_nfsip"

        fi

        #
        # We do IP change detection less frequently than unmount detection
        # since it will cause DNS calls on network.
        #
        if ! $do_ip_change_detection; then
            continue
        fi

        #
        # Check if blob endpoint IP address changed.
        # This is the migration check.
        #
        new_ip=$(resolve_ipv4 "$l_host" "false")

        # If we fail to resolve the host name, try next time.
        if [ $? -ne 0 ]; then
            #
            # If account is deleted then we need to delete the MOUNTMAP entry along
            # with the proxy iptable entry created for that account.
            # Note that we don't delete if the MOUNTMAP was changed recently since
            # the account may have been re-created after the dns lookup failure.
            #
            if [ "$new_ip" == "NXDOMAIN" ]; then
                pecho "Account corresponding to $l_host seems to have been deleted, deleting from ${MOUNTMAP} [$line]!"

                l_mtime=$(ensure_mountmap_not_exist "$line" "$mtime_mountmap")
                [ $? -eq 0 ] && mtime_mountmap=$l_mtime
            else
                eecho "resolve_ipv4($l_host) failed: $new_ip"
            fi
            continue
        fi

        #
        # If the IP changed for the Blob endpoint, we need to update the DNAT rule.
        # This will take care of migration/failover causing the Blob endpoint IP to change.
        #
        if [ "$new_ip" != "$l_nfsip" ]; then
            pecho "IP for $l_host changed [$l_nfsip -> $new_ip]."

            # This will update DNAT rule as well.
            if ! update_mountmap_entry "$line" "$l_host $l_ip $new_ip"; then
                eecho "Will reattempt the operation in next iteration."
            fi
        fi
    done
}

#
# Watchdog for monitoring unmounts and stunnel processes
#
processNFS4Mounts()
{
    local l_host
    local l_conf
    local l_log
    local l_pid
    local l_checksumhash

    epoch_now=$(date +%s)

    #
    # Go over all lines in $AZ_FILES_MOUNTMAP and check them for two things:
    # 1. Is that entry still in use by at least one aznfs mount, if not remove the entry.
    # 2. Is stunnel process running?
    #
    # We store the mtime of AZ_FILES_MOUNTMAP while inside the lock so that if any mount helper process
    # updates it after this we will skip modification for sake of safety. We will come to it
    # in the next iteration when it's safer.
    #
    exec {fd}<$AZ_FILES_MOUNTMAP
    flock -e $fd
    mtime_mountmap=$(stat -c%Y $AZ_FILES_MOUNTMAP)
    IFS=$'\n' lines=$(cat $AZ_FILES_MOUNTMAP)
    flock -u $fd
    exec {fd}<&-

    #
    # findmnt must be done after reading AZ_FILES_MOUNTMAP so that if we come accross a
    # AZ_FILES_MOUNTMAP entry whose all nfs file shares are unmounted, we know
    # for sure that it's not in use by any mount and can be removed.
    #
    findmnt=$(findmnt | grep 'nfs4\|$LOCALHOST' 2>&1)

    #
    # For no matching mounts also, findmnt exits with a failure return, so check
    # for both exit status and non-empty error o/p.
    #
    if [ $? -ne 0 -a -n "$findmnt" ]; then
        eecho "${findmnt}."
        eecho "[FATAL] findmnt failed unexpectedly!"
        eecho "[FATAL] Azfilenfs-watchdog service is exiting, will not monitor Azure NFS file shares."
        eecho "[FATAL] Please contact Microsoft support before using any NFS File shares."
        # This usually indicates some non-transient issue, bail out.
        exit 1
    fi

    for line in $lines; do
        if [ -z "$line" ]; then
            continue
        fi

        #
        # AZ_FILES_MOUNTMAP line is of the form:
        # account.file.preprod.core.windows.net;<stunnel_account.file.preprod.core.windows.net.conf path>;<stunnel_account.file.preprod.core.windows.net.log path>;<stunnel_account.file.preprod.core.windows.net.pid path>;<checksumHash>
        #
        IFS=";" read l_host l_conf l_log l_pid l_checksumhash <<< "$line"

        if [ -z "$l_host" -o -z "$l_conf" -o -z "$l_pid" ]; then
            wecho "[FATAL] Deleting invalid line in $AZ_FILES_MOUNTMAP: [$line]!"
            l_mtime=$(ensure_az_files_mountmap_not_exist "$line")
            [ $? -eq 0 ] && mtime_mountmap=$l_mtime
            continue
        fi

        accept_port=$(cat $l_conf | grep accept | cut -d ':' -f 2)
        vecho "accept_port: $accept_port"

        #
        # Delete entry from AZ_FILES_MOUNTMAP if there are no mounted shares on that host.
        # As long as we have at least one mount using the AZ_FILES_MOUNTMAP entry, we leave
        # it around.
        #
        if ! echo "$findmnt" | grep "$accept_port" >/dev/null; then
            pecho "No mounted shares for host $l_host, deleting from ${AZ_FILES_MOUNTMAP} [$line]."

            cleanupStunnelFiles $l_conf $l_log $l_pid

            # Delete IFF mountmap is not changed since we read it above.
            l_mtime=$(ensure_az_files_mountmap_not_exist "$line" "$mtime_mountmap")

            #
            # Update ifmatch time in case of successful updation of AZ_FILES_MOUNTMAP,
            # so that we can distinguish between AZ_FILES_MOUNTMAP mtime changing because
            # of our action or some mount helper changing it. In the former case
            # it's safe to update the AZ_FILES_MOUNTMAP, so update mtime_mountmap to the
            # mtime after this update.
            #
            [ $? -eq 0 ] && mtime_mountmap=$l_mtime
            continue
        else
            # Check if checksumHash for stunnel.conf file has changed.
            # Customers should not modify stunnel.conf files created by aznfs mount helper.
            checksumHash=`cksum $l_conf | awk '{print $1}'`
            if [ $? -ne 0 ]; then
                eecho "Failed to get the checksum hash of file: '${l_conf}'!"
            fi

            if [ $checksumHash != $l_checksumhash ]; then
                eecho "'${l_conf}' file has modified!"
                eecho "It's not recommended to modify '${l_conf}' file created by aznfs mount helper!"
                eecho "azfilenfs-watchdog service will do cleanup, kill stunnel process with pid:$(cat $l_pid) and remove '${l_conf}'; '${l_log}'; '${l_pid}'!"
                eecho "Please remount the shares from ${l_host} using aznfs mount helper."

                cleanupStunnelFiles $l_conf $l_log $l_pid

                # Delete IFF mountmap is not changed since we read it above.
                l_mtime=$(ensure_az_files_mountmap_not_exist "$line" "$mtime_mountmap")
                [ $? -eq 0 ] && mtime_mountmap=$l_mtime
                continue
            fi

            is_stunnel_running=$(netstat -anp | grep stunnel | grep `cat $l_pid`)
            if [ -z "$is_stunnel_running" ]; then
                vecho "stunnel is not running! Restarting the stunnel"

                stunnel_status=$(stunnel $l_conf 2>&1)
                if [ -n "$stunnel_status" ]; then
                    used_port=$(cat $l_conf | grep accept | cut -d: -f2)
                    is_binding_error=$(echo $stunnel_status | grep "$LOCALHOST:$used_port: Address already in use")
                    is_caroot_cert_failure=$(echo $stunnel_status | grep "certificate verify failed")
                    if [ -n "$is_binding_error" ]; then
                        eecho "[FATAL] Restarting stunnel failed.$used_port port is already being used by other process.!"
                        eecho "It's recommended to unmount all shares from $l_host and then remount shares using aznfs mount helper!"
                    elif [ -n "$is_caroot_cert_failure" ]; then
                        eecho "[FATAL] Restarting stunnel failed. CA root certificate is either missing or is unable to authenticate TLS server certificate."
                        eecho "Please download the CA root certificate from https://learn.microsoft.com/en-us/azure/security/fundamentals/azure-ca-details"
                        eecho "It's recommended to unmount all shares from $l_host and then remount shares using aznfs mount helper!"
                    else
                        eecho "[FATAL] azfilenfs-watchdog service is unable to start stunnel process for '${l_conf}'!"
                        eecho "Please check the stunnel logs in $l_log for more details."
                        eecho "It's recommended to unmount all shares from $l_host and then remount shares using aznfs mount helper!"
                    fi
                fi
            else
                vecho "stunnel is running!!"
            fi
        fi
    done
}


vecho "Starting aznfswatchdog..."

# Detect and log distro and bash version
if [ -f /etc/centos-release ]; then
    linux_distro=$(cat /etc/centos-release 2>&1)
elif [ -f /etc/os-release ]; then
    linux_distro=$(grep "^PRETTY_NAME=" /etc/os-release | awk -F= '{print $2}' | tr -d '"')
else
    linux_distro="Unknown"
fi

bash_version=$(bash --version | head -n 1)
vecho "Linux distribution: $linux_distro"
vecho "Bash version: $bash_version"

# Dump NAT table once on startup in case we have reported conflicts.
vecho "NAT table:\n$(iptables-save -t nat)"
conntrack -L > /dev/null

# conntrack timewait timeout higher than the TCP timewait timeout value isn't very valuable.
conntrack_timeo_timew=$(cat /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_time_wait 2>/dev/null)
if [ $? -eq 0 ] && [ -n "$conntrack_timeo_timew" -a $conntrack_timeo_timew -gt $AZNFS_TIMEWAIT_TIMEOUT ]; then
        vecho "Changing /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_time_wait [$conntrack_timeo_timew -> $AZNFS_TIMEWAIT_TIMEOUT]"
        echo $AZNFS_TIMEWAIT_TIMEOUT > /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_time_wait
fi

if ! chattr -f +i $MOUNTMAP; then
    wecho "chattr does not work for ${MOUNTMAP}!"
fi

# For NFS V4 mount map file
if [ ! -f $AZ_FILES_MOUNTMAP ]; then
    touch $AZ_FILES_MOUNTMAP
    if [ $? -ne 0 ]; then
        eecho "[FATAL] Not able to create '${AZ_FILES_MOUNTMAP}'!"
        exit 1
    fi
fi

if ! chattr -f +i $AZ_FILES_MOUNTMAP; then
    wecho "chattr does not work for ${AZ_FILES_MOUNTMAP}!"
fi


while :; do
    sleep $MONITOR_INTERVAL_SECS
    vecho "Processing NFSV3 mounts"
    processNFS3Mounts
    vecho "Processing NFSV4 mounts"
    processNFS4Mounts
done


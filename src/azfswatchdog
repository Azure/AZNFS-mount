#!/bin/bash 

#
# Load the functions used for logging.
#
. /sbin/log

#  
# How often does the watchdog look for unmounts and/or IP address changes for 
# Blob endpoints. 
# 
MONITOR_INTERVAL_SECS=5 

# 
# This stores the map of local IP and share name and external blob endpoint IP. 
# 
MOUNTMAP="/run/azblobnfs/mountmap"

#
# Check if the given string is a valid IPv4 address. 
# 
function is_valid_ipv4_address() 
{ 
    # ip route allows 10.10 as a valid address and treats it as 10.10.0.0, so we need the first coarse filter too. 
    [[ $1 =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] && 
    ip -4 route save match $1 > /dev/null 2>&1 
}

# 
# Check if the given string is probably a hostname (as opposed to an IP address). 
# 
function is_probably_hostname() 
{ 
    ! ip route save match $1 > /dev/null 2>&1
}

# 
# Blob fqdn to IPv4 adddress. 
# 
function resolve_ipv4() 
{ 
    local hname="$1" 

    # 
    # If already IPv4 address, return it. 
    # 
    if ! is_probably_hostname "$hname"; then 
        pecho "$hname" 
        return 0 
    fi 

    # 
    # else, resolve hostname to IPv4 address. 
    # 
    host_op=$(host -4 -t A "$hname") 
    if [ $? -ne 0 ]; then 
        eecho "Bad server: $hname" 
        return 1 
    fi 

    # 
    # TODO: We should disallow ZRS endpoints which resolve to multiple addresses. 
    #       Though we should handle public ZRS endpoints for handling cases where 
    #       the currently connected cluster goes down. 
    # 
    local cnt_ip=$(echo "$host_op" | grep " has address " | awk '{print $4}' | wc -l) 

    if [ $cnt_ip -ne 1 ]; then 
        eecho "host returned $cnt_ip address(es) for $hname, expected 1" 
        return 1 
    fi 

    local ipv4_addr=$(echo "$host_op" | grep " has address " | head -n1 | awk '{print $4}') 
    if ! is_valid_ipv4_address "$ipv4_addr"; then 
        eecho "host returned bad IPv4 address $ipv4_addr for hostname $hname!!" 
        return 1 
    fi 

    echo $ipv4_addr 
    return 0 
}

#
# MOUNTMAP is accessed by both mount.azfs and azfswatchdog service. Update it only after taking exclusive lock. 
#
function update_mountmap() 
{ 
    flock /run/azblobnfs/mountmap -c "eval $*" 
}

#
# Create the MOUNTMAP if it doesn't exists. 
#
if [ -d run ] then
    pecho " /run directory exist."
    
    if [ -d /run/azblobnfs ] then    
        pecho " /run/azblobnfs directory exist."
        
        if [ -f $MOUNTMAP ] then
            pecho "$MOUNTMAP exist."
        else
            touch $MOUNTMAP
            secho "Created $MOUNTMAP"
        fi
    else
        mkdir /run/azblobnfs
        touch $MOUNTMAP
        secho "Created $MOUNTMAP"
    fi
else 
    mkdir -p $MOUNTMAP
    secho "Created $MOUNTMAP"
fi

# 
# Watchdog for monitoring unmounts and more importantly change in blob endpoint 
# addresses possibly as a result of migration. 
# 
# Disable signal to make this slightly more resilient.
#
trap "" INT QUIT TSTP 

while :; do 
    sleep $MONITOR_INTERVAL_SECS 

    findmnt=$(findmnt --raw --noheading -o MAJ:MIN,FSTYPE,SOURCE,TARGET,OPTIONS -t nfs) 

    if [ $? -ne 0 ]; then 
        eecho "findmnt failed!" 
        # Hope things improve next time around! 
        continue 
    fi 

    # Nothing mounted, so nothing to check. 
    if [ -z "$findmnt" ]; then 
        continue 
    fi 

    # 
    # Go over all lines in $MOUNTMAP and check them for two things: 
    # 1. Is that entry still mounted, if not remove the entry. 
    # 2. Has the Blob endpoint address changed from what is stored? 
    #    If yes, update DNAT rule to point to the new address. 
    # 
    # Sample line in $MOUNTMAP. 
    # nfsv3stdaccount20.blob.preprod.core.windows.net:/nfsv3stdaccount20/fstestbase3 10.100.100.100 52.239.178.215 
    #  
    # where the format is 
    # <blobendpoint>:/account/container local_ip blobendpoint_ip 
    # 
    IFS=$'\n' lines=$(cat $MOUNTMAP) 

    for line in $lines; do 
        if [ -z "$line" ]; then 
            continue 
        fi 

        l_share=$(echo "$line" | awk '{print $1}') 
        l_host=$(echo "$l_share" | cut -d: -f1) 
        l_dir=$(echo "$l_share" | cut -d: -f2) 
        l_ip=$(echo "$line" | awk '{print $2}') 
        l_nfsip=$(echo "$line" | awk '{print $3}') 

        if [ -z "$l_host" -o -z "$l_dir" -o -z "$l_ip" -o -z "$l_nfsip" ]; then 
            wecho "Skipping invalid line in $MOUNTMAP: [$line]" 
            continue 
        fi 

        # Since we added it to the MOUNTMAP file, it cannot be invalid. 
        if ! is_valid_ipv4_address "$l_ip"; then 
            eecho "[BUG] local ip ($l_ip) is invalid!" 
            continue 
        fi

        # Since we added it to the MOUNTMAP file, it cannot be invalid. 
        if ! is_valid_ipv4_address "$l_nfsip"; then 
            eecho "[BUG] Blob endpoint ip ($l_nfsip) is invalid!" 
            continue 
        fi 

        # 
        # Local share name. Note that we mount the local IP and not the actual Blob endpoint IP and 
        # map local IP to actual Blob endpoint IP using DNAT rule. 
        # 
        m_share="$l_ip:$l_dir" 
      
        # 
        # Delete entry from MOUNTMAP if share is unmounted. 
        # TODO: What if user unmounts and mounts before MONITOR_INTERVAL_SECS secs? 
        # 
        if ! echo "$findmnt" | grep " nfs $m_share " > /dev/null; then 
            # delete the line from MOUNTMAP file. 
            pecho "[$date] Deleting unmounted share $m_share" 
            update_mountmap sed -i "/ $l_ip $l_nfsip/d" $MOUNTMAP
            iptables -t nat -D OUTPUT -p tcp -d "$l_ip" -j DNAT --to-destination "$l_nfsip" 
        fi 

        # 
        # Check if blob endpoint IP address changed. 
        # This is the migration check. 
        # 
        new_ip=$(resolve_ipv4 "$l_host") 

        # If we fail to resolve the host name, try next time.
        if [ $? -ne 0 ]; then 
            eecho "resolve_ipv4($l_host) failed!" 
            continue
        fi

        if ! is_valid_ipv4_address "$new_ip"; then 
            eecho "resolve_ipv4($l_host) returned invalid IPv4 address ($new_ip)!" 
            continue 
        fi 

        # 
        # If the IP changed for the Blob endpoint, we need to update the DNAT rule. 
        # This will take care of migration/failover causing the Blob endpoint IP to change. 
        # 
        # TODO: Make this less frequent than the unmount check. 
        # 
        # echo "$l_host: new_ip=$new_ip, l_nfsip=$l_nfsip"
        #
        if [ "$new_ip" != "$l_nfsip" ]; then 
            pecho "IP for $l_host changed [$l_nfsip -> $new_ip]"
            update_mountmap sed -i "/ $l_ip $l_nfsip/d" $MOUNTMAP

            # Delete old DNAT rule and the conntrack entry to stop current active connections too. 
            iptables -t nat -D OUTPUT -p tcp -d "$l_ip" -j DNAT --to-destination "$l_nfsip" 
            conntrack -D conntrack -p tcp -d "$l_ip" -r "$l_nfsip" 

            # Add new DNAT rule. 
            iptables -t nat -A OUTPUT -p tcp -d "$l_ip" -j DNAT --to-destination "$new_ip" 
            update_mountmap echo "$l_host:$l_dir $l_ip $new_ip" >> $MOUNTMAP
        fi 
    done 
done
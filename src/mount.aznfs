#!/bin/bash 

#
# Load common aznfs helpers.
# 
. /opt/microsoft/aznfs/common.sh

# 
# Default order in which we try the network prefixes for a free local IP to use.
# This can be overriden using AZNFS_IP_PREFIXES environment variable. 
# 
DEFAULT_AZNFS_IP_PREFIXES="10.100 192.168 172.16" 

IP_PREFIXES="${AZNFS_IP_PREFIXES:-${DEFAULT_AZNFS_IP_PREFIXES}}"

#
# Check if the given string is a valid blob FQDN (<accountname>.blob.core.windows.net).
#
is_valid_blob_fqdn() 
{ 
    # XXX Are there other valid blob endpoint fqdns? 
    [[ $1 =~ ^([a-z0-9]{3,24}).blob(.preprod)?.core.windows.net$ ]] 
} 

# 
# Get blob endpoint from account.blob.core.windows.net:/account/container. 
# 
get_host_from_share() 
{ 
    local hostshare="$1"
    local host=$(echo $hostshare | cut -d: -f1)
    local share=$(echo $hostshare | cut -d: -f2)

    if [ -z "$host" -o -z "$share" ]; then
        eecho "Bad share name: $hostshare"
        eecho "Share to be mounted must be of the form 'account.blob.core.windows.net:/account/container'."
        exit 1
    fi

    echo "$host"
} 

# 
# Get /account/container from account.blob.core.windows.net:/account/container.
# 
get_dir_from_share() 
{ 
    local hostshare="$1"
    local share=$(echo $hostshare | cut -d: -f2)
    local account=$(echo $share | cut -d/ -f1)
    local container=$(echo $share | cut -d/ -f2)
    local extra=$(echo $share | cut -d/ -f3)

    if [ -z "$account" -o -z "$container" -o -n "$extra" ]; then
        eecho "Bad share name: $hostshare"
        eecho "Share to be mounted must be of the form 'account.blob.core.windows.net:/account/container'."
        exit 1
    fi

    echo "$share"
} 

#
# Is the given address one of the host addresses? 
# 
is_host_ip() 
{ 
    #
    # Don't make this local as status gathering doesn't work well when 
    # collecting command o/p to local variables. 
    #
    route=$(ip -4 route get fibmatch $1 2>/dev/null) 
    if [ $? -ne 0 ]; then 
        return 1 
    fi 

    if ! echo "$route" | grep -q "scope host"; then 
        return 1 
    fi 

    return 0 
} 

# 
# Is the given address one of the addresses directly reachable from the host? 
# 
is_link_ip() 
{ 
    #
    # Don't make this local as status gathering doesn't work well when 
    # collecting command o/p to local variables. 
    #
    route=$(ip -4 route get fibmatch $1 2>/dev/null) 
    if [ $? -ne 0 ]; then 
        return 1 
    fi 

    if ! echo "$route" | grep -q "scope link"; then 
        return 1 
    fi 

    return 0 
} 

# 
# Check if a given IPv4 address is responding to ICMP pings. 
# Uses a 3 secs timeout to bail out in time if address is not responding. 
# 
is_pinging() 
{ 
    local ip=$1; 

    # 3 secs timeout should be good. 

    ping -4 -W3 -c1 $ip > /dev/null 
} 


# 
# Get a local IP that's free to use. 
# 
get_free_local_ip() 
{ 
    for ip_prefix in $IP_PREFIXES; do 

        local local_ip="" 

        # Start from 100 onwards to make aznfs local addresses more identifiable. 

        for ((_3rdoctet=100; _3rdoctet<255; _3rdoctet++)) { 
            ip_prefix="${ip_prefix}.$_3rdoctet" 

            if is_host_ip $ip_prefix; then 
                echo "$ip_prefix is host network!" 1>&2 
                continue 
            fi 

            if is_link_ip $ip_prefix; then 
                echo "$ip_prefix is link network!" 1>&2 
                continue 
            fi 

            break 
        } 

        if [ $_3rdoctet -eq 255 ]; then 
            continue 
        fi 

        if [ -z "$ip_prefix" ]; then 
            eecho "ip_prefix is nil!" 
            return 1 
        fi 

        for ((_4thoctet=100; _4thoctet<255; _4thoctet++)) { 
            local_ip="${ip_prefix}.$_4thoctet" 

            if egrep "\<$local_ip\>" $MOUNTMAP >/dev/null; then 
                pecho "$local_ip is in use by aznfs!" 1>&2 
                continue; 
            fi 

            # 
            # TODO: Do ping check to be sure the address is not in use in 
            #       the client's network. 
            # 

            pecho "Using local IP $local_ip for aznfs" 1>&2 
            break 
        } 

        if [ $_4thoctet -eq 255 ]; then 
            continue
        fi 

        if [ -z "$local_ip" ]; then 
            eecho "local_ip is nil!" 
            return 1 
        fi 

        # Happy path! 
        echo "$local_ip" 
        return 0 
    done 

    # 
    # If we come here we didn't get a free address to use. 
    # 

    eecho "Couldn't find a free local IP to use for aznfs using DEFAULT_AZNFS_IP_PREFIXES=$DEFAULT_AZNFS_IP_PREFIXES!" 
    eecho "Set AZNFS_IP_PREFIXES env variable correctly to provide free addresses for use by aznfs!" 

    return 1 
}

#
# Ensure aznfswatchdog service is running, if not bail out with an appropriate
# error.
#
# TODO: Make sure this works on all supported distros.  
#
ensure_aznfswatchdog()
{
    is_aznfswatchdog_active=$(systemctl is-active --quiet aznfswatchdog) 
    if [ $is_aznfswatchdog_active -ne 0 ]; then
        eecho "aznfswatchdog service not running!"
        pecho "Start the aznfswatchdog service using 'systemctl start aznfswatchdog' and try again."
        pecho "If the problem persists, contact Microsoft."
        exit 1
    fi
}

# [account.blob.core.windows.net:/account/container /mnt/aznfs -o rw,tcp,nolock,nconnect=16] 
vecho "[$(date -u)] Got arguments: [$*]"

#
# Check if aznfswatchdog service is running. 
#
ensure_aznfswatchdog

#
# MOUNTMAP file must have been created by aznfswatchdog service.
#
if [ ! -f $MOUNTMAP ]; then
    eecho "[FATAL] ${MOUNTMAP} not found!"
    pecho "Start the aznfswatchdog service using 'systemctl start aznfswatchdog' and try again."
    pecho "If the problem persists, contact Microsoft."
    exit 1
fi

nfs_host=$(get_host_from_share "$1") 

if ! is_valid_blob_fqdn $nfs_host; then 
    eecho "Not a valid Azure Blob NFS endpoint: ${nfs_host}."
    eecho "Must be of the form 'account.blob.core.windows.net'."
    exit 1 
fi

nfs_ip=$(resolve_ipv4 ${nfs_host})

if [ -z "$nfs_ip" ]; then 
    eecho "Cannot resolve IP address for $nfs_host!" 
    exit 1 
fi

#
# If user is using private endpoint then we can directly mount without the help
# of aznfswatchdog service.
#
if is_private_ip $nfs_ip; then
    vecho "Host IP is private ($nfs_ip), using direct NFS mount."
    mount -t nfs $*
    exit
fi

nfs_dir=$(get_dir_from_share "$1") 

if [ -z "$nfs_dir" ]; then
    eecho "Bad share name: $1"
    eecho "Share to be mounted must be of the form 'account.blob.core.windows.net:/account/container'." 
    exit 1 
fi 

mount_point="$2" 
mount_options="$4" 
 
local_ip=$(get_free_local_ip) 

echo "nfs_host=[$nfs_host]" 
echo "nfs_ip=[$nfs_ip]" 
echo "nfs_dir=[$nfs_dir]" 
echo "mount_point=[$mount_point]" 
echo "mount_options=[$mount_options]" 
echo "local_ip=$local_ip" 

# Set DNAT rule for forwarding local_ip traffic to the actual blob endpoint IP.
iptables -t nat -A OUTPUT -p tcp -d "$local_ip" -j DNAT --to-destination "$nfs_ip" 

if [ $? -ne 0 ]; then 
    eecho "iptables failed to set DNAT rule [$local_ip -> $nfs_ip]" 
    exit 1 
fi

mount -t nfs -o "$mount_options" "${local_ip}:${nfs_dir}" "$mount_point" 

if [ $? -ne 0 ]; then 
    eecho "mount failed!" 
    # clear the DNAT rule. 
    iptables -t nat -D OUTPUT -p tcp -d "$local_ip" -j DNAT --to-destination "$nfs_ip" 
    exit 1 
fi 

# Update MOUNTMAP.
update_mountmap echo "$nfs_host:$nfs_dir $local_ip $nfs_ip" >> $MOUNTMAP
 
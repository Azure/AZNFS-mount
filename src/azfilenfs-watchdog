#!/bin/bash

# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# --------------------------------------------------------------------------------------------

#
# How often does the watchdog look for unmounts and/or to track if stunnel processes are running for
# nfs file endpoints.
#
MONITOR_INTERVAL_SECS=5

#
# Don't perform mountmap and iptables rule cleanup for unmounted filesystems.
# This can be set if you want lazy umount to work.
#
AZNFS_SKIP_UNMOUNT_CLEANUP="${AZNFS_SKIP_UNMOUNT_CLEANUP:-0}"

# Load common aznfs helpers.
. /opt/microsoft/aznfs/common.sh
AZ_FILES_MOUNTMAP="$OPTDIR/aznfs_files_mountmap"


#
# Delete entry from $AZ_FILES_MOUNTMAP.
#
ensure_az_files_mountmap_not_exist()
{
    (
        flock -e 999

        #
        # If user wants to delete the entry only if AZ_FILES_MOUNTMAP has not changed since
        # he looked up, honour that.
        #
        local ifmatch="$2"
        if [ -n "$ifmatch" ]; then
            local mtime=$(stat -c%Y $AZ_FILES_MOUNTMAP)
            if [ "$mtime" != "$ifmatch" ]; then
                eecho "[$1] Refusing to remove from ${AZ_FILES_MOUNTMAP} as $mtime != $ifmatch!"
                return 1
            fi
        fi

	chattr -f -i $AZ_FILES_MOUNTMAP
        #
        # We do this thing instead of inplace update by sed as that has a
        # very bad side-effect of creating a new AZ_FILES_MOUNTMAP file. This breaks
        # any locking that we dependent on the old file.
        #
        out=$(sed "\%^${1}$%d" $AZ_FILES_MOUNTMAP)
        ret=$?
        if [ $ret -eq 0 ]; then
            #
            # If this echo fails then AZ_FILES_MOUNTMAP could be truncated.
            #
            echo "$out" > $AZ_FILES_MOUNTMAP
            ret=$?
            out=
            if [ $ret -ne 0 ]; then
                eecho "*** [FATAL] AZ_FILES_MOUNTMAP may be in inconsistent state, contact Microsoft support ***"
            fi
        fi

        if [ $ret -ne 0 ]; then
            chattr -f +i $AZ_FILES_MOUNTMAP
            eecho "[$1] failed to remove from ${AZ_FILES_MOUNTMAP}!"
            return 1
        fi
        chattr -f +i $AZ_FILES_MOUNTMAP

	# Return the mtime after our mods.
        echo $(stat -c%Y $AZ_FILES_MOUNTMAP)
    ) 999<$AZ_FILES_MOUNTMAP
}


vecho "Starting azfilenfs-watchdog..."

if [ ! -f $AZ_FILES_MOUNTMAP ]; then
	touch $AZ_FILES_MOUNTMAP
	if [ $? -ne 0 ]; then
		eecho "[FATAL] Not able to create '${AZ_FILES_MOUNTMAP}'!"
		exit 1
	fi
fi

if ! chattr -f +i $AZ_FILES_MOUNTMAP; then
    wecho "chattr does not work for ${AZ_FILES_MOUNTMAP}!"
fi

#
# Watchdog for monitoring unmounts and stunnel processes
#
while :; do
    sleep $MONITOR_INTERVAL_SECS

    epoch_now=$(date +%s)

    #
    # Go over all lines in $AZ_FILES_MOUNTMAP and check them for two things:
    # 1. Is that entry still in use by at least one aznfs mount, if not remove the entry.
    # 2. Is stunnel process running?
    #
    # We store the mtime of AZ_FILES_MOUNTMAP while inside the lock so that if any mount helper process
    # updates it after this we will skip modification for sake of safety. We will come to it
    # in the next iteration when it's safer.
    #
    exec {fd}<$AZ_FILES_MOUNTMAP
    flock -e $fd
    mtime_mountmap=$(stat -c%Y $AZ_FILES_MOUNTMAP)
    IFS=$'\n' lines=$(cat $AZ_FILES_MOUNTMAP)
    flock -u $fd
    exec {fd}<&-

    #
    # findmnt must be done after reading AZ_FILES_MOUNTMAP so that if we come accross a
    # AZ_FILES_MOUNTMAP entry whose all nfs file shares are unmounted, we know
    # for sure that it's not in use by any mount and can be removed.
    #
    findmnt=$(findmnt | grep 'nfs4\|127.0.0.1' 2>&1)

    #
    # For no matching mounts also, findmnt exits with a failure return, so check
    # for both exit status and non-empty error o/p.
    #
    if [ $? -ne 0 -a -n "$findmnt" ]; then
        eecho "${findmnt}."
        eecho "[FATAL] findmnt failed unexpectedly!"
        eecho "[FATAL] Azfilenfs-watchdog service is exiting, will not monitor Azure NFS file shares."
        eecho "[FATAL] Please contact Microsoft support before using any NFS File shares."
        # This usually indicates some non-transient issue, bail out.
        exit 1
    fi

    for line in $lines; do
        if [ -z "$line" ]; then
            continue
        fi

        #
        # AZ_FILES_MOUNTMAP line is of the form:
        # account.file.preprod.core.windows.net;<stunnel_account.file.preprod.core.windows.net.conf path>;<stunnel_account.file.preprod.core.windows.net.log path>;<stunnel_account.file.preprod.core.windows.net.pid path>;<checksumHash>
        #
        IFS=";" read l_host l_conf l_log l_pid l_checksumhash <<< "$line"

        if [ -z "$l_host" -o -z "$l_conf" -o -z "$l_pid" ]; then
            wecho "[FATAL] Deleting invalid line in $AZ_FILES_MOUNTMAP: [$line]!"
            l_mtime=$(ensure_az_files_mountmap_not_exist "$line")
            [ $? -eq 0 ] && mtime_mountmap=$l_mtime
            continue
        fi

	accept_port=$(cat $l_conf | grep accept | cut -d ':' -f 2)
	echo "accept_port: $accept_port"

        #
        # Delete entry from AZ_FILES_MOUNTMAP if there are no mounted shares on that host.
        # As long as we have at least one mount using the AZ_FILES_MOUNTMAP entry, we leave
        # it around.
        #
        if ! echo "$findmnt" | grep "$accept_port" >/dev/null; then
                pecho "No mounted shares for host $l_host, deleting from ${AZ_FILES_MOUNTMAP} [$line]."

		# Kill stunnel process first.
		pid=$(cat $l_pid)
		kill -9 $pid
		if [ $? -ne 0 ]; then
		    eecho "[FATAL] Unable to kill stunnel process '$pid'!"
		    exit 1
		fi

		# Cleanup stunnel files
		rm $l_log
		if [ $? -ne 0 ]; then
		    eecho "[FATAL] Unable to delete stunnel log file $l_log!"
		    exit 1
		fi

		rm $l_pid
		if [ $? -ne 0 ]; then
		    eecho "[FATAL] Unable to delete stunnel pid file $l_pid!"
		    exit 1
		fi

		chattr -if $l_conf
		rm $l_conf
		if [ $? -ne 0 ]; then
		    eecho "[FATAL] Unable to delete stunnel conf file $l_conf!"
		    exit 1
		fi

                # Delete IFF mountmap is not changed since we read it above.
                l_mtime=$(ensure_az_files_mountmap_not_exist "$line" "$mtime_mountmap")

                #
                # Update ifmatch time in case of successful updation of AZ_FILES_MOUNTMAP,
                # so that we can distinguish between AZ_FILES_MOUNTMAP mtime changing because
                # of our action or some mount helper changing it. In the former case
                # it's safe to update the AZ_FILES_MOUNTMAP, so update mtime_mountmap to the
                # mtime after this update.
                #
                [ $? -eq 0 ] && mtime_mountmap=$l_mtime
                continue
        else
	    is_stunnel_running=$(netstat -anp | grep stunnel | grep `cat $l_pid`)
	    echo "$is_stunnel_running"
	    if [ -z "$is_stunnel_running" ]; then
                vecho "stunnel is not running! Restarting the stunnel"

                stunnel_status=$(stunnel $l_conf 2>&1)
		if [ -n "$stunnel_status" ]; then
		    eecho "[FATAL] Not able to start stunnel process for '${l_conf}'!"
                    exit 1
		fi
	    fi
        fi

    done

done
